---
layout: post
title: iOS代码规范
description: iOS代码规范
date: 2017-06-14 
tags: 代码规范   
---
![配图来自：nipic.com](http://upload-images.jianshu.io/upload_images/859001-a9d78ce3d5e7114f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

利用上周的业余时间把这篇规范整理了出来，我会将这篇规范作为我们iOS团队的代码规范，并且还会根据读者的反馈，项目的实践和研究的深入做不定时更新，还希望各位朋友看了多多指正和批评。

这篇规范一共分为三个部分：

1.  核心原则：介绍了这篇代码规范所遵循的核心原则。
2.  通用规范：不局限于iOS的通用性的代码规范（使用C语言和Swift语言）。
3.  iOS规范：仅适用于iOS的代码规范（使用Objective-C语言）。
<a id="more"></a>

# [](#一-核心原则 "一. 核心原则")一. 核心原则

## [](#原则一：代码应该简洁易懂，逻辑清晰 "原则一：代码应该简洁易懂，逻辑清晰")原则一：代码应该简洁易懂，逻辑清晰

因为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机：

*   不要过分追求技巧，降低程序的可读性。
*   简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。

## [](#原则二：面向变化编程，而不是面向需求编程。 "原则二：面向变化编程，而不是面向需求编程。")原则二：面向变化编程，而不是面向需求编程。

需求是暂时的，只有变化才是永恒的。
本次迭代不能仅仅为了当前的需求，写出扩展性强，易修改的程序才是负责任的做法，对自己负责，对公司负责。

## [](#原则三：先保证程序的正确性，防止过度工程 "原则三：先保证程序的正确性，防止过度工程")原则三：先保证程序的正确性，防止过度工程

过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑扩展，重用的问题，使得工程过度复杂。
引用《[王垠：编程的智慧](http://www.jianshu.com/p/7645a5ea7f46)》里的话：

> 1.  先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。
> 2.  先写出可用的代码，反复推敲，再考虑是否需要重用的问题。
> 3.  先写出可用，简单，明显没有bug的代码，再考虑测试的问题。

# [](#二-通用规范 "二. 通用规范")二. 通用规范

## [](#关于大括号 "关于大括号")关于大括号

* * *

*   控制语句(if,for,while,switch)中，大括号开始与行尾
*   函数中，大括号要开始于行首

推荐这样写：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//控制语句</span></div><div class="line">white(someCondition)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//函数</span></div><div class="line"><span class="keyword">void</span> function(param1,param2)</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

## [](#运算符 "运算符")运算符

* * *

### [](#1-运算符与变量之间的间隔 "1. 运算符与变量之间的间隔")1. 运算符与变量之间的间隔

#### [](#1-1-一元运算符与变量之间没有空格： "1.1  一元运算符与变量之间没有空格：")1.1  一元运算符与变量之间没有空格：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!bValue</div><div class="line">~iValue</div><div class="line">++iCount</div><div class="line">*strSource</div><div class="line">&amp;fSum</div></pre></td></tr></table></figure>

#### [](#1-2-二元运算符与变量之间必须有空格 "1.2 二元运算符与变量之间必须有空格")1.2 二元运算符与变量之间必须有空格
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fWidth = <span class="number">5</span> + <span class="number">5</span>;</div><div class="line">fLength = fWidth * <span class="number">2</span>;</div><div class="line">fHeight = fWidth + fLength;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div></pre></td></tr></table></figure>

### [](#2-多个不同的运算符同时存在时应该使用括号来明确优先级 "2. 多个不同的运算符同时存在时应该使用括号来明确优先级")2. 多个不同的运算符同时存在时应该使用括号来明确优先级

在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。
因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。

来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4

这里的`&lt;&lt;`是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 1 _ 3 - 4
但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 1 _ 3 - 4)。
所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。

## [](#变量 "变量")变量

* * *

### [](#1-一个变量有且只有一个功能，尽量不要把一个变量用作多种用途 "1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途")1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途

### [](#2-变量在使用前应初始化，防止未初始化的变量被引用 "2. 变量在使用前应初始化，防止未初始化的变量被引用")2. 变量在使用前应初始化，防止未初始化的变量被引用

### [](#3-局部变量应该尽量接近使用它的地方 "3. 局部变量应该尽量接近使用它的地方")3. 局部变量应该尽量接近使用它的地方

推荐这样写：

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> index = ...;</div><div class="line">  <span class="comment">//Do something With index</span></div><div class="line"></div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = ...;</div><div class="line">  <span class="comment">//Do something With count</span></div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> index = ...;</div><div class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = ...;</div><div class="line">  <span class="comment">//Do something With index</span></div><div class="line"></div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="comment">//Do something With count</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

## [](#if语句 "if语句")if语句

* * *

### [](#1-必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。 "1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。")1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。

推荐这样写：

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hintStr;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">count</span> &lt; <span class="number">3</span>) &#123;</div><div class="line">  hintStr = <span class="string">"Good"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  hintStr = <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hintStr;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">count</span> &lt; <span class="number">3</span>) &#123;</div><div class="line"> hintStr = <span class="string">"Good"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#2-不要使用过多的分支，要善于使用return来提前返回错误的情况 "2. 不要使用过多的分支，要善于使用return来提前返回错误的情况")2. 不要使用过多的分支，要善于使用return来提前返回错误的情况

推荐这样写：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)someMethod &#123; </div><div class="line">  <span class="keyword">if</span> (!goodCondition) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)someMethod &#123; </div><div class="line">  <span class="keyword">if</span> (goodCondition) &#123;</div><div class="line">    <span class="comment">//Do something</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

比较典型的例子我在JSONModel里遇到过：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>)err</div><div class="line">&#123;</div><div class="line">   <span class="comment">//方法1. 参数为nil</span></div><div class="line">   <span class="keyword">if</span> (!dict) &#123;</div><div class="line">     <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];</div><div class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法2. 参数不是nil，但也不是字典</span></div><div class="line">    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法3. 初始化</span></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//初始化失败</span></div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO）</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span>.__keyMapper error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法5. 核心方法：字典的key与模型的属性的映射</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span>.__keyMapper validation:<span class="literal">YES</span> error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法7. 终于通过了！成功返回model</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
> 可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。

### [](#3-条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值 "3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值")3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let nameContainsSwift = sessionName.hasPrefix(<span class="string">"Swift"</span>)</div><div class="line">let isCurrentYear = sessionDateCompontents.year == <span class="number">2014</span></div><div class="line">let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYear</div><div class="line"><span class="keyword">if</span> (isSwiftSession) &#123; </div><div class="line">   <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( sessionName.hasPrefix(<span class="string">"Swift"</span>) &amp;&amp; (sessionDateCompontents.year == <span class="number">2014</span>) ) &#123; </div><div class="line">    <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#4-条件语句的判断应该是变量在左，常量在右 "4. 条件语句的判断应该是变量在左，常量在右")4. 条件语句的判断应该是变量在左，常量在右

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( count == <span class="number">6</span>) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

或者
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( object == <span class="literal">nil</span>) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

或者
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !object ) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="number">6</span> == count) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

或者
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="literal">nil</span> == object ) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#5-每个分支的实现代码都必须被大括号包围 "5. 每个分支的实现代码都必须被大括号包围")5. 每个分支的实现代码都必须被大括号包围

推荐这样写：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error) &#123;</div><div class="line">  <span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error)</div><div class="line">    <span class="keyword">return</span> success;</div></pre></td></tr></table></figure>

或者

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error) <span class="keyword">return</span> success;</div></pre></td></tr></table></figure>

### [](#6-条件过多，过长的时候应该换行 "6. 条件过多，过长的时候应该换行")6. 条件过多，过长的时候应该换行

推荐这样写：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition1() &amp;&amp; </div><div class="line">    condition2() &amp;&amp; </div><div class="line">    condition3() &amp;&amp; </div><div class="line">    condition4()) &#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

## [](#for语句 "for语句")for语句

* * *

### [](#1-不可在for循环内修改循环变量，防止for循环失去控制。 "1. 不可在for循环内修改循环变量，防止for循环失去控制。")1. 不可在for循环内修改循环变量，防止for循环失去控制。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)&#123;</div><div class="line">   ...</div><div class="line">   logicToChange(index)</div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#2-避免使用continue和break。 "2. 避免使用continue和break。")2. 避免使用continue和break。

continue和break所描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。

其实最好不要让这两个东西出现，因为我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的：

#### [](#2-1-如果出现了continue，只需要把continue的条件取反即可 "2.1 如果出现了continue，只需要把continue的条件取反即可")2.1 如果出现了continue，只需要把continue的条件取反即可
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filteredProducts = <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">    <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    &#125;</div><div class="line">    filteredProducts.append(level)</div><div class="line">&#125;</div></pre></td></tr></table></figure>

我们可以看到，通过判断字符串里是否含有“bad”这个prefix来过滤掉一些值。其实我们是可以通过取反，来避免使用continue的：
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">    <span class="keyword">if</span> !level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">      filteredProducts.append(level)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

#### [](#2-2-消除while里的break：将break的条件取反，并合并到主循环里 "2.2  消除while里的break：将break的条件取反，并合并到主循环里")2.2  消除while里的break：将break的条件取反，并合并到主循环里

在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以在最开始的条件语句中将其排除。

while里的break：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition1) &#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">if</span> (condition2) &#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

取反并合并到主条件：

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition1 &amp;&amp; !condition2) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>

#### [](#2-3-在有返回值的方法里消除break：将break转换为return立即返回 "2.3 在有返回值的方法里消除break：将break转换为return立即返回")2.3 在有返回值的方法里消除break：将break转换为return立即返回

有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasBadProductIn</span><span class="params">(products: Array&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = <span class="literal">false</span>    </div><div class="line">    <span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">        <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">            result = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>

遇到错误条件直接返回：

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasBadProductIn</span><span class="params">(products: Array&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">        <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。

## [](#Switch语句 "Switch语句")Switch语句

* * *

### [](#1-每个分支都必须用大括号括起来 "1. 每个分支都必须用大括号括起来")1. 每个分支都必须用大括号括起来

推荐这样写：
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (integer) &#123;  </div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>:  &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">   &#125;</div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">  <span class="keyword">case</span> <span class="number">2</span>: &#123;  </div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">case</span> <span class="number">3</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">default</span>:&#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#2-使用枚举类型时，不能有default分支，-除了使用枚举类型以外，都必须有default分支 "2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支")2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="type">RWTLeftMenuTopItemType</span> menuType = <span class="type">RWTLeftMenuTopItemMain</span>;  </div><div class="line"><span class="keyword">switch</span> (menuType) &#123;  </div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemMain</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">   &#125;</div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemShows</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemSchedule</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。

## [](#函数 "函数")函数

* * *

### [](#1-一个函数的长度必须限制在50行以内 "1. 一个函数的长度必须限制在50行以内")1. 一个函数的长度必须限制在50行以内

通常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。

### [](#2-一个函数只做一件事（单一原则） "2. 一个函数只做一件事（单一原则）")2. 一个函数只做一件事（单一原则）

每个函数的职责都应该划分的很明确（就像类一样）。

推荐这样写：

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataConfiguration()</div><div class="line">viewConfiguration()</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dataConfiguration</span><span class="params">()</span></span></div><div class="line">&#123;   </div><div class="line">   ...</div><div class="line">   viewConfiguration()</div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#3-对于有返回值的函数（方法），每一个分支都必须有返回值 "3. 对于有返回值的函数（方法），每一个分支都必须有返回值")3. 对于有返回值的函数（方法），每一个分支都必须有返回值

推荐这样写：

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(condition1)&#123;</div><div class="line">        <span class="keyword">return</span> count1</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</div><div class="line">        <span class="keyword">return</span> count2</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">       <span class="keyword">return</span> defaultCount</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(condition1)&#123;</div><div class="line">        <span class="keyword">return</span> count1</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</div><div class="line">        <span class="keyword">return</span> count2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#4-对输入参数的正确性和有效性进行检查，参数错误立即返回 "4. 对输入参数的正确性和有效性进行检查，参数错误立即返回")4. 对输入参数的正确性和有效性进行检查，参数错误立即返回

推荐这样写：

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(param1,param2)</span></span></div><div class="line">&#123;</div><div class="line">      <span class="keyword">if</span>(param1 is unavailable)&#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      <span class="keyword">if</span>(param2 is unavailable)&#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     <span class="comment">//Do some right thing</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#5-如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数 "5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数")5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数

原来的调用：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> logic() &#123;</div><div class="line">  a();</div><div class="line">  b()；</div><div class="line">  <span class="keyword">if</span> (logic1 condition) &#123;</div><div class="line">    c();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    d();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

将a，b函数抽取出来作为单独的函数
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> basicConfig() &#123;</div><div class="line">  a();</div><div class="line">  b();</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">void</span> logic1() &#123;</div><div class="line">  basicConfig();</div><div class="line">  c();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> logic2() &#123;</div><div class="line">  basicConfig();</div><div class="line">  d();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#6-将函数内部比较复杂的逻辑提取出来作为单独的函数 "6. 将函数内部比较复杂的逻辑提取出来作为单独的函数")6. 将函数内部比较复杂的逻辑提取出来作为单独的函数

一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。

举一个发送邮件的例子：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">openEmailSite();</div><div class="line">login();</div><div class="line"></div><div class="line">writeTitle(title);</div><div class="line">writeContent(content);</div><div class="line">writeReceiver(receiver);</div><div class="line">addAttachment(attachment);</div><div class="line"></div><div class="line">send();</div></pre></td></tr></table></figure>

中间的部分稍微长一些，我们可以将它们提取出来：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeEmail</span><span class="params">(title, content,receiver,attachment)</span></span></div><div class="line">&#123;</div><div class="line">  writeTitle(title);</div><div class="line">  writeContent(content);</div><div class="line">  writeReceiver(receiver);</div><div class="line">  addAttachment(attachment); </div><div class="line">&#125;</div></pre></td></tr></table></figure>

然后再看一下原来的代码：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">openEmailSite();</div><div class="line">login();</div><div class="line">writeEmail(title, content,receiver,attachment)</div><div class="line">send();</div></pre></td></tr></table></figure>

### [](#8-避免使用全局变量，类成员（class-member）来传递信息，尽量使用局部变量和参数。 "8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。")8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。

在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了：

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">   <span class="keyword">var</span> x;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">updateX</span><span class="params">()</span></span> &#123;</div><div class="line">      ...</div><div class="line">      x = ...;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">printX</span><span class="params">()</span></span> &#123;</div><div class="line">     updateX();</div><div class="line">     <span class="built_in">print</span>(x);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>

我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。

而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func updateX() -&gt; String&#123;</div><div class="line">    x = ...;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> func printX() &#123;</div><div class="line">   String x = updateX();</div><div class="line">   print(x);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>

## [](#注释 "注释")注释

* * *

优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。

但并不是说一定不能写注释，有以下三种情况比较适合写注释：

1.  公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。
2.  涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。
3.  容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。

除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。

最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。

## [](#Code-Review "Code Review")Code Review

* * *

换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。

而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。

# [](#三-iOS规范 "三. iOS规范")三. iOS规范

## [](#变量-1 "变量")变量

* * *

### [](#1-变量名必须使用驼峰格式 "1. 变量名必须使用驼峰格式")1. 变量名必须使用驼峰格式

类，协议使用大驼峰：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HomePageViewController.h</div><div class="line">&lt;HeaderViewDelegate&gt;</div></pre></td></tr></table></figure>

对象等局部变量使用小驼峰：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *personName = <span class="string">@""</span>;</div><div class="line"><span class="built_in">NSUInteger</span> totalCount = <span class="number">0</span>;</div></pre></td></tr></table></figure>

### [](#2-变量的名称必须同时包含功能与类型 "2. 变量的名称必须同时包含功能与类型")2. 变量的名称必须同时包含功能与类型
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *addBtn <span class="comment">//添加按钮</span></div><div class="line"><span class="built_in">UILabel</span> *nameLbl <span class="comment">//名字标签</span></div><div class="line"><span class="built_in">NSString</span> *addressStr<span class="comment">//地址字符串</span></div></pre></td></tr></table></figure>

### [](#3-系统常用类作实例变量声明时加入后缀 "3. 系统常用类作实例变量声明时加入后缀")3. 系统常用类作实例变量声明时加入后缀
<table>
<thead>
<tr>
<th>类型</th>
<th>后缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>UIViewController</td>
<td>VC</td>
</tr>
<tr>
<td>UIView</td>
<td>View</td>
</tr>
<tr>
<td>UILabel</td>
<td>Lbl</td>
</tr>
<tr>
<td>UIButton</td>
<td>Btn</td>
</tr>
<tr>
<td>UIImage</td>
<td>Img</td>
</tr>
<tr>
<td>UIImageView</td>
<td>ImagView </td>
</tr>
<tr>
<td>NSArray</td>
<td>Array</td>
</tr>
<tr>
<td>NSMutableArray</td>
<td>Marray</td>
</tr>
<tr>
<td>NSDictionary</td>
<td>Dict</td>
</tr>
<tr>
<td>NSMutableDictionary</td>
<td>Mdict</td>
</tr>
<tr>
<td>NSString</td>
<td>Str</td>
</tr>
<tr>
<td>NSMutableString</td>
<td>MStr</td>
</tr>
<tr>
<td>NSSet</td>
<td>Set</td>
</tr>
<tr>
<td>NSMutableSet</td>
<td>Mset</td>
</tr>
</tbody>
</table>

## [](#常量 "常量")常量

* * *

### [](#1-常量以相关类名作为前缀 "1. 常量以相关类名作为前缀")1. 常量以相关类名作为前缀

推荐这样写：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> ZOCSignInViewControllerFadeOutAnimationDuration = <span class="number">0.4</span>;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> fadeOutTime = <span class="number">0.4</span>;</div></pre></td></tr></table></figure>

### [](#2-建议使用类型常量，不建议使用-define预处理命令 "2. 建议使用类型常量，不建议使用#define预处理命令")2. 建议使用类型常量，不建议使用#define预处理命令

首先比较一下这两种声明常量的区别：

*   预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。
*   类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。

使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的：

*   不具备类型信息。
*   可以被任意修改。

### [](#3-对外公开某个常量： "3. 对外公开某个常量：")3. 对外公开某个常量：

如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头文件</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> ZOCCacheControllerDidClearCacheNotification;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现文件</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCCacheControllerDidClearCacheNotification = <span class="string">@"ZOCCacheControllerDidClearCacheNotification"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> ZOCImageThumbnailHeight = <span class="number">50.0</span>f;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define CompanyName @<span class="meta-string">"Apple Inc."</span> </span></div><div class="line"><span class="meta">#define magicNumber 42</span></div></pre></td></tr></table></figure>

## [](#宏 "宏")宏

* * *

### [](#1-宏、常量名都要使用大写字母，用下划线‘-’分割单词。 "1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。")1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define URL_GAIN_QUOTE_LIST @<span class="meta-string">"/v1/quote/list"</span></span></div><div class="line"><span class="meta">#define URL_UPDATE_QUOTE_LIST @<span class="meta-string">"/v1/quote/update"</span></span></div><div class="line"><span class="meta">#define URL_LOGIN  @<span class="meta-string">"/v1/user/login”</span></span></div></pre></td></tr></table></figure>

### [](#2-宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。 "2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。")2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define MY_MIN(A, B)  ((A)&gt;(B)?(B):(A))</span></div></pre></td></tr></table></figure>

## [](#CGRect函数 "CGRect函数")CGRect函数

* * *

其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用：

推荐这样写：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame; </div><div class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame); </div><div class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</div></pre></td></tr></table></figure>

而不是
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;  </div><div class="line"><span class="built_in">CGFloat</span> x = frame.origin.x;  </div><div class="line"><span class="built_in">CGFloat</span> y = frame.origin.y;  </div><div class="line"><span class="built_in">CGFloat</span> width = frame.size.width;  </div><div class="line"><span class="built_in">CGFloat</span> height = frame.size.height;  </div><div class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; .origin = <span class="built_in">CGPointZero</span>, .size = frame.size &#125;;</div></pre></td></tr></table></figure>

## [](#范型 "范型")范型

* * *

建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *testArr = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Hello"</span>, <span class="string">@"world"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSNumber</span> *&gt; *dic = @&#123;<span class="string">@"key"</span>:@(<span class="number">1</span>), <span class="string">@"age"</span>:@(<span class="number">10</span>)&#125;;</div></pre></td></tr></table></figure>

## [](#Block "Block")Block

* * *

为常用的Block类型创建typedef

如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型

例如：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123;</div><div class="line">     // Implementation</div><div class="line">     return someInt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型：

<figure class="highlight plain"><figcaption><span>int(^EOCSomeBlock)(BOOL flag, int value);```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">再次定义的时候，就可以通过简单的赋值来实现：</div></pre></td></tr></table></figure>

EOCSomeBlock block = ^(BOOL flag, int value){
     // Implementation
};

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">定义作为参数的Block：</div></pre></td></tr></table></figure>

*   (void)startWithCompletionHandler: (void(^)(NSData _data, NSError _error))completion;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里的Block有一个NSData参数，一个NSError参数并没有返回值</div></pre></td></tr></table></figure>

typedef void(^EOCCompletionHandler)(NSData _data, NSError _error);

*   (void)startWithCompletionHandler:(EOCCompletionHandler)completion;”<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。</div><div class="line"></div><div class="line"></div><div class="line">## 字面量语法</div><div class="line">---</div><div class="line"></div><div class="line">尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象：</div><div class="line"></div><div class="line">推荐这样写：</div><div class="line">```objc</div><div class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</div><div class="line">NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;; </div><div class="line">NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span> ];</div><div class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];<span class="built_in">NSNumber</span> *buildingZIPCode = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</div></pre></td></tr></table></figure>

## [](#属性 "属性")属性

* * *

### [](#1-属性的命名使用小驼峰 "1. 属性的命名使用小驼峰")1. 属性的命名使用小驼峰

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIButton</span> *confirmButton;</div></pre></td></tr></table></figure>

### [](#2-属性的关键字推荐按照-原子性，读写，内存管理的顺序排列 "2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列")2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *headerView;</div></pre></td></tr></table></figure>

### [](#3-Block属性应该使用copy关键字 "3. Block属性应该使用copy关键字")3. Block属性应该使用copy关键字

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^ErrorCodeBlock) (<span class="keyword">id</span> errorCode,<span class="built_in">NSString</span> *message);</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) ErrorCodeBlock errorBlock;<span class="comment">//将block拷贝到堆中</span></div></pre></td></tr></table></figure>

### [](#4-形容词性的BOOL属性的getter应该加上is前缀 "4. 形容词性的BOOL属性的getter应该加上is前缀")4. 形容词性的BOOL属性的getter应该加上is前缀

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</div></pre></td></tr></table></figure>

### [](#5-使用getter方法做懒加载 "5. 使用getter方法做懒加载")5. 使用getter方法做懒加载

实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123;</div><div class="line">    <span class="keyword">if</span> (!_dateFormatter) &#123;</div><div class="line">           _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">           <span class="built_in">NSLocale</span> *enUSPOSIXLocale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</div><div class="line">           [_dateFormatter setLocale:enUSPOSIXLocale];</div><div class="line">           [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd'T'HH:mm:ss.SSS"</span>];</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> _dateFormatter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。

### [](#6-除了init和dealloc方法，建议都使用点语法访问属性 "6. 除了init和dealloc方法，建议都使用点语法访问属性")6. 除了init和dealloc方法，建议都使用点语法访问属性

使用点语法的好处：

#### [](#setter： "setter：")setter：

1.  setter会遵守内存管理语义(strong, copy, weak)。
2.  通过在内部设置断点，有助于调试bug。
3.  可以过滤一些外部传入的值。
4.  捕捉KVO通知。

#### [](#getter： "getter：")getter：

1.  允许子类化。
2.  通过在内部设置断点，有助于调试bug。
3.  实现懒加载（lazy initialization）。
> 注意：
> 
> 1.  懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。
> 2.  在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。

### [](#7-不要滥用点语法，要区分好方法调用和属性访问 "7. 不要滥用点语法，要区分好方法调用和属性访问")7. 不要滥用点语法，要区分好方法调用和属性访问

推荐这样写：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.backgroundColor = [<span class="built_in">UIColor</span> orangeColor]; </div><div class="line">[<span class="built_in">UIApplication</span> sharedApplication].delegate;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]]; </div><div class="line"><span class="built_in">UIApplication</span>.sharedApplication.delegate;</div></pre></td></tr></table></figure>

### [](#8-尽量使用不可变对象 "8. 尽量使用不可变对象")8. 尽量使用不可变对象

建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是：

*   在头文件中，设置对象属性为<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- 在实现文件中设置为```readwrite```。</div><div class="line"></div><div class="line">这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。</div><div class="line"></div><div class="line">如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本,例如：</div><div class="line"></div><div class="line">在公共API中：</div></pre></td></tr></table></figure>

@interface EOCPerson : NSObject

@property (nonatomic, copy, readonly) NSString _firstName;
@property (nonatomic, copy, readonly) NSString _lastName;
@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合

*   (id)initWithFirstName:(NSString_)firstName andLastName:(NSString_)lastName;
*   (void)addFriend:(EOCPerson*)person;
*   (void)removeFriend:(EOCPerson*)person;

@end

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。</div><div class="line"></div><div class="line">在实现文件里：</div></pre></td></tr></table></figure>

@interface EOCPerson ()

@property (nonatomic, copy, readwrite) NSString _firstName;
@property (nonatomic, copy, readwrite) NSString _lastName;

@end

@implementation EOCPerson {
     NSMutableSet *_internalFriends;  //实现文件里的可变集合
}

*   (NSSet*)friends {
   return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型
}

*   (void)addFriend:(EOCPerson*)person {
  [_internalFriends addObject:person]; //在外部增加集合元素的操作
  //do something when add element
}

*   (void)removeFriend:(EOCPerson*)person {
  [_internalFriends removeObject:person]; //在外部移除元素的操作
  //do something when remove element
}

*   (id)initWithFirstName:(NSString_)firstName andLastName:(NSString_)lastName {

       if ((self = [super init])) {

        _firstName = firstName;
    _lastName = lastName;
    _internalFriends = [NSMutableSet new];

  }
return self;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以看到，在实现文件里，保存一个可变set来记录外部的增删操作。</div><div class="line"></div><div class="line">这里最重要的代码是：</div></pre></td></tr></table></figure>

*   (NSSet*)friends {
return [_internalFriends copy];
}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;这个是friends属性的获取方法：它将当前保存的可变set复制了一不可变的set并返回。因此，外部读取到的set都将是不可变的版本。</div><div class="line"></div><div class="line">## 方法</div><div class="line">----</div><div class="line"></div><div class="line">### 1. 方法名中不应使用and，而且签名要与对应的参数名保持高度一致</div><div class="line"></div><div class="line">推荐这样写：</div><div class="line"></div><div class="line">```objc</div><div class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width andHeight:(<span class="built_in">CGFloat</span>)height;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWith:(<span class="keyword">int</span>)width and:(<span class="keyword">int</span>)height;</div></pre></td></tr></table></figure>

### [](#2-方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。 "2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。")2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doSomethingWith:(<span class="built_in">NSString</span> *)theFoo</div><div class="line">                   rect:(<span class="built_in">CGRect</span>)theRect</div><div class="line">               interval:(<span class="built_in">CGFloat</span>)theInterval</div><div class="line">&#123;</div><div class="line">   <span class="comment">//Implementation</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#3-私有方法应该在实现文件中申明。 "3. 私有方法应该在实现文件中申明。")3. 私有方法应该在实现文件中申明。
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">- (<span class="keyword">void</span>)basicConfiguration;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)basicConfiguration</div><div class="line">&#123;</div><div class="line">   <span class="comment">//Do some basic configuration</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

### [](#4-方法名用小写字母开头的单词组合而成 "4. 方法名用小写字母开头的单词组合而成")4. 方法名用小写字母开头的单词组合而成
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)descriptionWithLocale:(<span class="keyword">id</span>)locale;</div></pre></td></tr></table></figure>

### [](#5-方法名前缀 "5. 方法名前缀")5. 方法名前缀

*   刷新视图的方法名要以`refresh`为首。
*   更新数据的方法名要以`update`为首。

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)refreshHeaderViewWithCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line">- (<span class="keyword">void</span>)updateDataSourceWithViewModel:(ViewModel*)viewModel;</div></pre></td></tr></table></figure>

## [](#面向协议编程 "面向协议编程")面向协议编程

* * *

如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。

因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子：

现在有一个需求：在一个`UITableViewController`里面拉取feed并展示出来。

### [](#方案一： "方案一：")方案一：

定义一个拉取feed的类`ZOCFeedParser`，这个类有一些代理方法实现feed相关功能：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)feedParserDidStart:(ZOCFeedParser *)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; </div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item; </div><div class="line">- (<span class="keyword">void</span>)feedParserDidFinish:(ZOCFeedParser *)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didFailWithError:(<span class="built_in">NSError</span> *)error;<span class="keyword">@end</span> </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCFeedParser</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;ZOCFeedParserDelegate&gt; delegate; </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> *url; </div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url; </div><div class="line">- (<span class="built_in">BOOL</span>)start; </div><div class="line">- (<span class="keyword">void</span>)stop; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

然后在`ZOCTableViewController`里面传入`ZOCFeedParser`，并遵循其代理方法，实现feed的拉取功能。

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCTableViewController</span> : <span class="title">UITableViewController</span>&lt;<span class="title">ZOCFeedParserDelegate</span>&gt;</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFeedParser:(ZOCFeedParser *)feedParser; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

具体应用：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *feedURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://bbc.co.uk/feed.rss"</span>]; </div><div class="line">ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL]; </div><div class="line">ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser]; </div><div class="line">feedParser.delegate = tableViewController;</div></pre></td></tr></table></figure>

OK，现在我们实现了需求：在`ZOCTableViewController`里面存放了一个`ZOCFeedParser`对象来处理feed的拉取功能。

但这里有一个严重的耦合问题：`ZOCTableViewController`只能通过`ZOCFeedParser`对象来处理feed的拉取功能。
于是我们重新审视一下这个需求：其实我们实际上只需要`ZOCTableViewController`拉取feed就可以了，而具体是由哪个对象来拉取，`ZOCTableViewController`并不需要关心。

也就是说，我们需要提供给`ZOCTableViewController`的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（`ZOCFeedParser`）。所以，刚才的设计需要重新做一次修改：

### [](#方案二： "方案二：")方案二：

首先需要在一个接口文件`ZOCFeedParserProtocol.h`里面定义抽象的，具有拉取feed功能的协议：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)feedParserDidStart:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; </div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item; </div><div class="line">- (<span class="keyword">void</span>)feedParserDidFinish:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(<span class="built_in">NSError</span> *)error;<span class="keyword">@end</span> </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;ZOCFeedParserDelegate&gt; delegate; </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> *url;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)start;</div><div class="line">- (<span class="keyword">void</span>)stop;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

而原来的`ZOCFeedParser`仅仅是需要遵循上面这个协议就具备了拉取feed的功能：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCFeedParser</span> : <span class="title">NSObject</span> &lt;<span class="title">ZOCFeedParserProtocol</span>&gt; </span></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url;<span class="comment">//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end</span></div></pre></td></tr></table></figure>

而且，`ZOCTableViewController`也不直接依赖于`ZOCFeedParser`对象，我们只需要传给它一个遵循`&lt;ZOCFeedParserProtocol&gt;`的对象即可。

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCTableViewController</span> : <span class="title">UITableViewController</span> &lt;<span class="title">ZOCFeedParserDelegate</span>&gt;</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFeedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)feedParser;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

这样一来，`ZOCTableViewController`和`ZOCFeedParser`之间就没有直接的关系了。以后，如果我们想：

*   给这个feed拉取器增加新的功能：仅需要修改`ZOCFeedParserProtocol.h`文件。
*   更换一个feed拉取器实例：创建一个新类型来遵循`ZOCFeedParserProtocol.h`即可。

## [](#iOS-中委托的设计 "iOS 中委托的设计")iOS 中委托的设计

* * *

### [](#1-要区分好代理和数据源的区别 "1. 要区分好代理和数据源的区别")1. 要区分好代理和数据源的区别

在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：

*   delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）
*   datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）

然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div></pre></td></tr></table></figure>

这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div></pre></td></tr></table></figure>

该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。

在UITableViewDataSource中，就有标准的数据源方法：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView;</div></pre></td></tr></table></figure>

这个方法的作用就是让tableview向控制器拉取一个section数量的数据。

所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。

### [](#2-代理方法的第一个参数必须为委托者 "2. 代理方法的第一个参数必须为委托者")2. 代理方法的第一个参数必须为委托者

代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在``

*   (void)tableView:(UITableView _)tableView didSelectRowAtIndexPath:(NSIndexPath _)indexPath``方法中做个区分。

### [](#向代理发送消息时需要判断其是否实现该方法 "向代理发送消息时需要判断其是否实现该方法")向代理发送消息时需要判断其是否实现该方法

最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法:

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(signUpViewControllerDidPressSignUpButton:)]) &#123; </div><div class="line"> [<span class="keyword">self</span>.delegate signUpViewControllerDidPressSignUpButton:<span class="keyword">self</span>]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#3-遵循代理过多的时候，换行对齐显示 "3. 遵循代理过多的时候，换行对齐显示")3. 遵循代理过多的时候，换行对齐显示
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ShopViewController</span> () &lt;<span class="title">UIGestureRecognizerDelegate</span>,</span></div><div class="line">                                  HXSClickEventDelegate,</div><div class="line">                                  <span class="built_in">UITableViewDelegate</span>,</div><div class="line">                                  <span class="built_in">UITableViewDataSource</span>&gt;</div></pre></td></tr></table></figure>

### [](#4-代理的方法需要明确必须执行和可不执行 "4. 代理的方法需要明确必须执行和可不执行")4. 代理的方法需要明确必须执行和可不执行

代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用`@optional`关键字来修饰：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCServiceDelegate</span> &lt;<span class="title">NSObject</span>&gt;@<span class="title">optional</span>- (<span class="title">void</span>)<span class="title">generalService</span>:(<span class="title">ZOCGeneralService</span> *)<span class="title">service</span> <span class="title">didRetrieveEntries</span>:(<span class="title">NSArray</span> *)<span class="title">entries</span>; </span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

## [](#类 "类")类

* * *

### [](#1-类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间 "1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间")1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间

推荐这样写：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//父类</span></div><div class="line">ZOCSalesListViewController</div><div class="line"></div><div class="line"><span class="comment">//子类</span></div><div class="line">ZOCDaySalesListViewController</div><div class="line">ZOCMonthSalesListViewController</div></pre></td></tr></table></figure>

### [](#2-initializer-amp-amp-dealloc "2. initializer &amp;&amp; dealloc")2. initializer &amp;&amp; dealloc

推荐：

*   将 dealloc 方法放在实现文件的最前面
*   将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。

#### [](#2-1-dealloc方法里面应该直接访问实例变量，不应该用点语法访问 "2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问")2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问

#### [](#2-2-init方法的写法： "2.2 init方法的写法：")2.2 init方法的写法：

*   init方法返回类型必须是instancetype，不能是id。
*   必须先实现[super init]。
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init &#123; </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; <span class="comment">// call the designated initializer </span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123; </div><div class="line">        <span class="comment">// Custom initialization </span></div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

#### [](#2-3-指定初始化方法 "2.3 指定初始化方法")2.3 指定初始化方法

指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。

注意事项1：间接初始化方法必须调用指定初始化方法。

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZOCEvent</span> </span></div><div class="line"></div><div class="line"><span class="comment">//指定初始化方法</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title date:(<span class="built_in">NSDate</span> *)date </div><div class="line">location:(<span class="built_in">CLLocation</span> *)location</div><div class="line">&#123; </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; </div><div class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">         _title = title; </div><div class="line">         _date = date; </div><div class="line">         _location = location; </div><div class="line">      &#125; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//间接初始化方法</span></div><div class="line">-  (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title date:(<span class="built_in">NSDate</span> *)date</div><div class="line">&#123; </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithTitle:title date:date location:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//间接初始化方法</span></div><div class="line">-  (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title </div><div class="line">&#123; </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithTitle:title date:[<span class="built_in">NSDate</span> date] location:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"> <span class="keyword">@end</span></div></pre></td></tr></table></figure>

注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤

1.  定义新的指定初始化方法，并确保调用了直接父类的初始化方法。
2.  重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。
3.  为新的指定初始化方法写文档。

看一个标准的例子：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZOCNewsViewController</span></span></div><div class="line"></div><div class="line"><span class="comment">//新的指定初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithNews:(ZOCNews *)news &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:<span class="literal">nil</span> bundle:<span class="literal">nil</span>]; </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _news = news;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// 重载父类的初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithNews:<span class="literal">nil</span>]; </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。

假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。

而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令`__attribute__((objc_designated_initializer))`来标记它。

### [](#3-所有返回类对象和实例对象的方法都应该使用instancetype "3. 所有返回类对象和实例对象的方法都应该使用instancetype")3. 所有返回类对象和实例对象的方法都应该使用instancetype

将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象）

推荐这样写：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCPerson</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)personWithName:(<span class="built_in">NSString</span> *)name; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCPerson</span></span></div><div class="line">+ (<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

### [](#4-在类的头文件中尽量少引用其他头文件 "4. 在类的头文件中尽量少引用其他头文件")4. 在类的头文件中尽量少引用其他头文件

有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// EOCPerson.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">EOCEmployer</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EOCEmployer *employer;<span class="comment">//将EOCEmployer作为属性</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// EOCPerson.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"EOCEmployer.h"</span></span></div></pre></td></tr></table></figure>

这样做有什么优点呢：

> *   不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。
> *   可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。

但是个别的时候，必须在头文件中引入其他类的头文件:

> 主要有两种情况：
> 
> 1.  该类继承于某个类，则应该引入父类的头文件。
> 2.  该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。

### [](#5-类的布局 "5. 类的布局")5. 类的布局
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#pragma mark - Life Cycle Methods</span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Override Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Intial Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Network Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Target Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Public Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Private Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - UITableViewDataSource  </span></div><div class="line"><span class="meta">#pragma mark - UITableViewDelegate  </span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Lazy Loads</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSCopying  </span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSObject  Methods</span></div></pre></td></tr></table></figure>

## [](#分类 "分类")分类

* * *

### [](#1-分类添加的方法需要添加前缀和下划线 "1. 分类添加的方法需要添加前缀和下划线")1. 分类添加的方法需要添加前缀和下划线

推荐这样写：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">ZOCTimeExtensions</span>)</span></div><div class="line"> - (<span class="built_in">NSString</span> *)zoc_timeAgoShort;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

不推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">ZOCTimeExtensions</span>) </span></div><div class="line">- (<span class="built_in">NSString</span> *)timeAgoShort;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

### [](#2-把类的实现代码分散到便于管理的多个分类中 "2. 把类的实现代码分散到便于管理的多个分类中")2. 把类的实现代码分散到便于管理的多个分类中

一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。

举个🌰：

先看一个没有使用无分类的类：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSArray *friends;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">/* Friendship methods */</div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">/* Work methods */</div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line"></div><div class="line">/* Play methods */</div><div class="line">- (void)goToTheCinema;</div><div class="line">- (void)goToSportsGame;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>

分类之后：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSArray *friends;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName</div><div class="line"></div><div class="line">andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Work)</div><div class="line"></div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Play)</div><div class="line"></div><div class="line">- (void)goToTheCinema;</div><div class="line">- (void)goToSportsGame;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>

其中，FriendShip分类的实现代码可以这么写：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// EOCPerson+Friendship.h</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson+Friendship.m</div><div class="line">#import &quot;EOCPerson+Friendship.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeFriend:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
> 注意：在新建分类文件时，一定要引入被分类的类文件。

通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。

利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。

## [](#单例 "单例")单例

* * *

### [](#1-单例不能作为容器对象来使用 "1. 单例不能作为容器对象来使用")1. 单例不能作为容器对象来使用

单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。

### [](#2-使用dispatch-once来生成单例 "2. 使用dispatch_once来生成单例")2. 使用dispatch_once来生成单例

推荐这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123; </div><div class="line"> <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>; </div><div class="line"> <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken = <span class="number">0</span>;</div><div class="line">       <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </div><div class="line">  sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">  &#125;); </div><div class="line"> <span class="keyword">return</span> sharedInstance; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

不推荐这样写：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123; </div><div class="line"> <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance; </div><div class="line"> <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; </div><div class="line"> <span class="keyword">if</span> (sharedInstance == <span class="literal">nil</span>) &#123;  sharedInstance = [[MyClass alloc] init]; </div><div class="line"> &#125; &#125; </div><div class="line"> <span class="keyword">return</span> sharedInstance; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

## [](#相等性的判断 "相等性的判断")相等性的判断

* * *

判断两个person类是否相等的合理做法：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-  (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> == object) &#123;  <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">//判断内存地址</span></div><div class="line"> &#125; </div><div class="line">  <span class="keyword">if</span> (![object isKindOfClass:[ZOCPerson <span class="keyword">class</span>]]) &#123; </div><div class="line">     <span class="keyword">return</span> <span class="literal">NO</span>; <span class="comment">//是否为当前类或派生类 &#125; </span></div><div class="line"> <span class="keyword">return</span> [<span class="keyword">self</span> isEqualToPerson:(ZOCPerson *)object]; </div><div class="line"> </div><div class="line">&#125;</div><div class="line"><span class="comment">//自定义的判断相等性的方法</span></div><div class="line">-  (<span class="built_in">BOOL</span>)isEqualToPerson:(Person *)person &#123; </div><div class="line">        <span class="keyword">if</span> (!person) &#123;  <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">  &#125; <span class="built_in">BOOL</span> namesMatch = (!<span class="keyword">self</span>.name &amp;&amp; !person.name) || [<span class="keyword">self</span>.name isEqualToString:person.name]; <span class="built_in">BOOL</span> birthdaysMatch = (!<span class="keyword">self</span>.birthday &amp;&amp; !person.birthday) || [<span class="keyword">self</span>.birthday isEqualToDate:person.birthday]; <span class="keyword">return</span> haveEqualNames &amp;&amp; haveEqualBirthdays; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

## [](#方法文档 "方法文档")方法文档

* * *

一个函数(方法)必须有一个字符串文档来解释，除非它：

*   非公开，私有函数。
*   很短。
*   显而易见。

而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：

*   以/开始
*   第二行识总结性的语句
*   第三行永远是空行
*   在与第二行开头对齐的位置写剩下的注释。

建议这样写：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/This comment serves to demonstrate the format of a doc string.</div><div class="line"></div><div class="line">Note that the summary line is always at most one line <span class="keyword">long</span>, and after the opening block comment,</div><div class="line">and each line of text is preceded by a single space.</div><div class="line">*/</div></pre></td></tr></table></figure>

看一个指定初始化方法的注释：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/ </div><div class="line">  *  Designated initializer. *</div><div class="line">  *  @param store The store <span class="keyword">for</span> CRUD operations.</div><div class="line">  *  @param searchService The search service used to query the store. </div><div class="line">  *  @return A ZOCCRUDOperationsStore object.</div><div class="line">  */ </div><div class="line">- (<span class="keyword">instancetype</span>)initWithOperationsStore:(<span class="keyword">id</span>&lt;ZOCGenericStoreProtocol&gt;)store searchService:(<span class="keyword">id</span>&lt;ZOCGenericSearchServiceProtocol&gt;)searchService;</div></pre></td></tr></table></figure>

### [](#多用队列，少用同步锁来避免资源抢夺 "多用队列，少用同步锁来避免资源抢夺")多用队列，少用同步锁来避免资源抢夺

* * *

多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。

#### [](#方案一：使用串行同步队列来将读写操作都安排到同一个队列里： "方案一：使用串行同步队列来将读写操作都安排到同一个队列里：")方案一：使用串行同步队列来将读写操作都安排到同一个队列里：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_queue_create(<span class="string">"com.effectiveobjectivec.syncQueue"</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">//读取字符串</span></div><div class="line">- (<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">         __block <span class="built_in">NSString</span> *localSomeString;</div><div class="line">         <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">            localSomeString = _someString;</div><div class="line">        &#125;);</div><div class="line">         <span class="keyword">return</span> localSomeString;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置字符串</span></div><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

这样一来，读写操作都在串行队列进行，就不容易出错。

但是，还有一种方法可以让性能更高：

#### [](#方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。 "方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。")方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">//读取字符串</span></div><div class="line">- (<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     __block <span class="built_in">NSString</span> *localSomeString;</div><div class="line">     <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">     <span class="keyword">return</span> localSomeString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置字符串</span></div><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。
这里的`dispatch_barrier_async`方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。

## [](#实现description方法打印自定义对象信息 "实现description方法打印自定义对象信息")实现description方法打印自定义对象信息

* * *

在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：`object = &lt;EOCPerson: 0x7fd9a1600600&gt;`

这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。

但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。

例如：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)description &#123;</div><div class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p, %@ %@&gt;"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>, firstName, lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>

在这里，显示了内存地址，还有该类的所有属性。

而且，如果我们将这些属性值放在字典里打印，则更具有可读性：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)description &#123;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p, %@&gt;"</span>,[<span class="keyword">self</span> <span class="keyword">class</span>],<span class="keyword">self</span>,</div><div class="line">   </div><div class="line">    @&#123;    <span class="string">@"title"</span>:_title,</div><div class="line">       <span class="string">@"latitude"</span>:@(_latitude),</div><div class="line">      <span class="string">@"longitude"</span>:@(_longitude)&#125;</div><div class="line">    ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>

输出结果：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location = &lt;EOCLocation: <span class="number">0x7f98f2e01d20</span>, &#123;</div><div class="line"></div><div class="line">    latitude = <span class="string">"51.506"</span>;</div><div class="line">   longitude = <span class="number">0</span>;</div><div class="line">       title = London;</div><div class="line">&#125;&gt;</div></pre></td></tr></table></figure>

我们可以看到，通过重写`description`方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。

## [](#NSArray-amp-NSMutableArray "NSArray&amp; NSMutableArray")NSArray&amp; NSMutableArray

* * *

### [](#1-addObject之前要非空判断。 "1. addObject之前要非空判断。")1. addObject之前要非空判断。

### [](#2-取下标的时候要判断是否越界。 "2. 取下标的时候要判断是否越界。")2. 取下标的时候要判断是否越界。

### [](#3-取第一个元素或最后一个元素的时候使用firtstObject和lastObject "3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject")3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject

## [](#NSCache "NSCache")NSCache

* * *

### [](#1-构建缓存时选用NSCache-而非NSDictionary "1. 构建缓存时选用NSCache 而非NSDictionary")1. 构建缓存时选用NSCache 而非NSDictionary

如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。

在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。

### [](#2-NSCache优于NSDictionary的几点： "2. NSCache优于NSDictionary的几点：")2. NSCache优于NSDictionary的几点：

*   当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。
*   NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。
*   NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。

## [](#NSNotification "NSNotification")NSNotification

* * *

### [](#1-通知的名称 "1. 通知的名称")1. 通知的名称

建议将通知的名字作为常量，保存在一个专门的类中：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Const.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCFooDidBecomeBarNotification</div><div class="line"></div><div class="line"><span class="comment">// Const.m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCFooDidBecomeBarNotification = <span class="string">@"ZOCFooDidBecomeBarNotification"</span>;</div></pre></td></tr></table></figure>

### [](#2-通知的移除 "2. 通知的移除")2. 通知的移除

通知必须要在对象销毁之前移除掉。

## [](#其他 "其他")其他

* * *

### [](#1-Xcode工程文件的物理路径要和逻辑路径保持一致。 "1. Xcode工程文件的物理路径要和逻辑路径保持一致。")1. Xcode工程文件的物理路径要和逻辑路径保持一致。

### [](#2-忽略没有使用变量的编译警告 "2. 忽略没有使用变量的编译警告")2. 忽略没有使用变量的编译警告

对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除：

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)giveMeFive &#123; </div><div class="line"> <span class="built_in">NSString</span> *foo; </div><div class="line"> <span class="meta">#pragma unused (foo) </span></div><div class="line"> <span class="keyword">return</span> <span class="number">5</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

### [](#3-手动标明警告和错误 "3. 手动标明警告和错误")3. 手动标明警告和错误

#### [](#手动明确一个错误： "手动明确一个错误：")手动明确一个错误：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)divide:(<span class="built_in">NSInteger</span>)dividend by:(<span class="built_in">NSInteger</span>)divisor &#123; </div><div class="line"> <span class="meta">#error Whoa, buddy, you need to check for zero here! </span></div><div class="line"> <span class="keyword">return</span> (dividend / divisor); </div><div class="line">&#125;</div></pre></td></tr></table></figure>

#### [](#手动明确一个警告： "手动明确一个警告：")手动明确一个警告：
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">float</span>)divide:(<span class="keyword">float</span>)dividend by:(<span class="keyword">float</span>)divisor &#123; </div><div class="line"> <span class="meta">#warning Dude, don't compare floating point numbers like this! </span></div><div class="line"> <span class="keyword">if</span> (divisor != <span class="number">0.0</span>) &#123; </div><div class="line">  <span class="keyword">return</span> (dividend / divisor); </div><div class="line"> &#125; <span class="keyword">else</span> &#123;  <span class="keyword">return</span> NAN; </div><div class="line"> &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

* * *        